import { app, BrowserWindow, ipcMain } from 'electron';

import fetch from 'node-fetch';
import { parse } from 'node-html-parser';
import { Database } from 'sqlite3';
import { existsSync, lstatSync, mkdirSync } from 'fs';
import { spawn } from 'child_process';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const APP_NAME = "skin"
const DATA_DIR = `${process.env.HOME}/.${APP_NAME}`
const DB_FILE_PATH = `${DATA_DIR}/database.sqlite3`

const default_how_to_open_url_map: { [key: string]: { cmd: string, args: string[] } } = {
    "http:": { cmd: "open", args: [] },
    "https:": { cmd: "open", args: [] },
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    autoHideMenuBar:true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

//-
class UrlOpenCommand {
    cmd: string
    args: string[]

    constructor(cmd: string, args: string[]) {
        this.cmd = cmd
        this.args = args
    }

    open(url: string) {
        let url_index = this.args.findIndex(a => a === "$url")
        let args = this.args.concat() // clone

        if (url_index === -1) {
            args.push(url)
        } else {
            args[url_index] = url
        }

        spawn(this.cmd, args)
    }
}

function how_to_open_url(protcol: string): UrlOpenCommand | null {
    // なんかバグが生まれそう
    // todo
    // ディープコピーを取る実装に変える
    const map: { [key: string]: { cmd: string, args: string[] } } = Object.assign({}, default_how_to_open_url_map)

    let open_cmd = map[protcol]

    if (open_cmd === undefined) {
        return null
    }

    return new UrlOpenCommand(open_cmd.cmd, open_cmd.args)
}

function make_url_search_google(tags:string[]):string{
    return `https://www.google.com/search?q=${tags.join("+")}`
}

function search_google(tags:string[]){
    let url = make_url_search_google(tags)
    let open_cmd = how_to_open_url(new URL(url).protocol)
    open_cmd.open(url)
}

async function open_bookmark(bookmark_id: number):Promise<null> {
    let bookmark = await wrap_db_get(querys.get_bkmk_from_id, bookmark_id)

    if (bookmark.err) {
        console.error(bookmark.err.message)
        return null
    }

    if (bookmark.row === undefined) {
        return null
    }

    let url = new URL(bookmark.row.url)

    let cmd = how_to_open_url(url.protocol)

    if (cmd === null) {
        return null
    }

    cmd.open(bookmark.row.url)

    return null
}

function value_check_tag(tag: string) {
    if (tag.includes(",")) {
        return {
            err: true,
            message: "タグにコンマが含まれています"
        }
    }

    return {
        err: false,
        message: ""
    }
}

async function tag_exists(tag: string) {
    let res = await wrap_db_get(querys.get_tag_id, [tag])
    if (res.err) {
        console.error(res.err.message)
        throw Error()
    }

    return res.row !== undefined
}

async function wrap_db_all(query: string, params: any): Promise<{ err: Error | null, rows: any[] }> {
    return new Promise(resolve => {
        db.all(query, params, (err, rows) => {
            resolve({ err, rows })
        })
    })
}

async function wrap_db_get(query: string, params: any): Promise<{ err: Error | null, row: any }> {
    return new Promise(resolve => {
        db.get(query, params, (err, row) => {
            resolve({ err, row })
        })
    })
}

async function wrap_db_run(query: string, params: any): Promise<Error | null> {
    return new Promise(resolve => {
        db.run(query, params, (err) => {
            resolve(err)
        })
    })
}

async function search_bookmarks(tags: string[]) {
    let query = querys.search_bookmark(tags.length)
    let res = await wrap_db_all(query, tags)
    if (res.err) {
        console.error(res.err.message)
        return []
    }
    return res.rows
}

async function handleAddBookmark(url: string, title: string, tags: string[],description: string): Promise<{ err: boolean, message: string }> {
    //
    // SQL文で実行すれば性能がよくなるかもしれないのにJSで実装している箇所
    //  繰り返し処理
    //  挿入したデータのIDを検索している
    //  
    // 理由
    //  SQLは苦手
    //  データの追加の処理だから性能は求めてない
    //

    //
    // バリデーションチェック
    //
    let errs = tags.map(t => value_check_tag(t)).filter(r => r.err === true)
    if (errs.length > 0) {
        return {
            err: true,
            message: errs.map(e => e.message).join("\n")
        }
    }


    //
    // テーブルにないタグを追加
    //
    let require_add_tags = []
    for (let i = 0; i < tags.length; i++) {
        const tag = tags[i];
        if (await tag_exists(tag) === false) {
            require_add_tags.push(tag)
        }
    }
    for (let i = 0; i < require_add_tags.length; i++) {
        const tag = require_add_tags[i];
        let res = await wrap_db_run(querys.add_tag, [tag])
        if (res) { return { err: true, message: res.message } }
    }


    //
    // bookmarksに追加
    //
    let result_add_bkmk = await wrap_db_run(querys.add_bkmk, [title, url,description])


    //
    // bookmarkとtagを結び付ける
    //
    let bkmk_id = await wrap_db_get(querys.get_bkmk_id, [title, url])
    let tag_ids = []
    for (let i = 0; i < tags.length; i++) {
        let res = await wrap_db_get(querys.get_tag_id, tags[i])
        if (res.err) { return { err: true, message: res.err.message } }
        tag_ids.push(res.row)
    }
    for (let i = 0; i < tags.length; i++) {
        let params = [bkmk_id.row.id, tag_ids[i].id]
        let res = await wrap_db_run(querys.add_tag_map, params)
        if (res) { return { err: true, message: res.message } }
    }


    return {
        err: false,
        message: ""
    }
}

async function handleFetchSuggestion(word: string) {
    word = word + "%"
    let result = await wrap_db_all(querys.fetch_suggestion, word)
    if (result.err) {
        return {
            err: true,
            message: result.err.message,
            data: null
        }
    }
    return {
        err: false,
        message: "",
        data: result.rows
    }
}


//----------------------------------------------------------------------------------------------------//
//                                                                                                    //
//                                             SQL QUERY                                              //
//                                                                                                    //
//----------------------------------------------------------------------------------------------------//
const querys = {
    init: `
        create table if not exists bookmarks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title text,
            url text,
            description text
        );

        create table if not exists tags (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name text
        );

        create table if not exists tag_map (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            bkmk_id int,
            tag_id int,
            FOREIGN KEY (bkmk_id) REFERENCES bookmarks (id),
            FOREIGN KEY (tag_id) REFERENCES tags (id)
        );
        `,

    search_bookmark: (length: number) => {
        let s = new Array(length).fill("?").join(",")
        return `
        SELECT b.*
        FROM bookmarks b
        JOIN tag_map tm ON b.id = tm.bkmk_id
        JOIN tags t ON tm.tag_id = t.id
        WHERE t.name IN (${s})
        GROUP BY b.id
        HAVING COUNT(DISTINCT t.name) = ${length};
        `
    },
    get_tag_id: "select id from tags where name = ?",
    add_tag: "insert into tags values (null,?)",
    get_bkmk_id: "select id from bookmarks where title = ? and url = ?;",
    add_bkmk: "insert into bookmarks values (null,?,?,?);",
    add_tag_map: "insert into tag_map values (null,?,?)",
    get_bkmk_from_id: "select * from bookmarks where id = ?",
    fetch_suggestion: "select name from tags where name like ?;",


    // TODO RENAME
    exists_tags: (len: number) => {
        let where = new Array(len).fill("where = ?")
        let stmt = "select id from tags " + where.join(" or ")
        return stmt
    }
}



//----------------------------------------------------------------------------------------------------//
//                                                                                                    //
//                                                MAIN                                                //
//                                                                                                    //
//----------------------------------------------------------------------------------------------------//

if (!existsSync(DATA_DIR)) {
    mkdirSync(DATA_DIR, { recursive: true })
} else if (lstatSync(DATA_DIR).isFile()) {
    throw Error()
}

const db = new Database(DB_FILE_PATH, (err) => {
    if (err !== null) {
        console.error("connect", err)
        throw err
    }

    db.exec(querys.init, (err) => {
        if (err) {
            console.error("query_init", err)
            throw err
        }
    });
})

ipcMain.handle("add-bkmk", async (_, url, title, tags,description) => {
    let res = await handleAddBookmark(url, title, tags,description)
    return res
})

ipcMain.handle("fetch-suggestion", async (_, word) => {
    return await handleFetchSuggestion(word)
})

ipcMain.handle("fetch-pageinfo",async (_,url) => {
    let res

    try{
        res = await fetch(url)
    }catch{
        return null
    }

    if (res.status !== 200) {
        return null
    }

    let text = await res.text()

    let root = parse(text)
    let title_elm = root.querySelector("title")
    let title = title_elm === null ? null : title_elm.innerText

    let description_elm = root.querySelector('meta[name="description"]')
    let description = description_elm === null ? null : description_elm.attrs.content

    return {
        title,
        description
    }

})


ipcMain.handle("search-google",(_,tags) => {
    search_google(tags)
})

ipcMain.handle("tag-exists-db", async (_, tag_name) => {
    return await tag_exists(tag_name)
})


ipcMain.handle("search-bookmarks", async (_, tags: string[]) => {
    return await search_bookmarks(tags)
})

ipcMain.handle("open-bookmark", async (_, bookmark_id: number) => {
    return await open_bookmark(bookmark_id)
})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

app.setName(APP_NAME)