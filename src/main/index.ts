import { app, BrowserWindow, ipcMain } from 'electron';

import fetch from 'node-fetch';
import { parse } from 'node-html-parser';
import { Database } from 'sqlite3';
import { existsSync, lstatSync, mkdirSync } from 'fs';
import { spawn } from 'child_process';
import { readFileSync, writeFileSync } from 'original-fs';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const APP_NAME = "skin"
const DATA_DIR = `${process.env.HOME}/.${APP_NAME}`
const DB_FILE_PATH = `${DATA_DIR}/database.sqlite3`
const CONFIG_DIR = `${process.env.HOME}/.config/${APP_NAME}`
const CONFIG_FILE_PATH = `${CONFIG_DIR}/config.json`

type Config = {
    how_to_open_url: { [key: string]: { cmd: string, args: string[] } }
}

const default_how_to_open_url: { [key: string]: { cmd: string, args: string[] } } = {
    "http": { cmd: "open", args: [] },
    "https": { cmd: "open", args: [] },
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
    app.quit();
}

const createWindow = (): void => {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        autoHideMenuBar: true,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

function make_url_search_google(tags: string[]): string {
    return `https://www.google.com/search?q=${tags.join("+")}`
}

function search_google(tags: string[]) {
    let url = make_url_search_google(tags)
    open_url(url)
}


function open_url(url: string) {

    console.log("call open url", url)

    let protcol = url.split(":")[0]
    if (protcol === "") {
        return
    }

    let opener = config.how_to_open_url[protcol]
    if (opener === undefined) {
        return
    }

    let args = opener.args.concat() // clone
    let url_index = args.findIndex(a => a === "$url")

    if (url_index === -1) {
        args.push(url)
    } else {
        args[url_index] = url
    }

    spawn(opener.cmd, args)
}

async function open_bookmark(bookmark_id: number): Promise<null> {
    let bookmark = await wrap_db_get(querys.get_bkmk_from_id, bookmark_id)

    if (bookmark.err) {
        console.error(bookmark.err.message)
        return null
    }

    if (bookmark.row === undefined) {
        return null
    }

    open_url(bookmark.row.url)

    return null
}

function value_check_tag(tag: string) {
    if (tag.includes(",")) {
        return {
            err: true,
            message: "タグにコンマが含まれています"
        }
    }

    return {
        err: false,
        message: ""
    }
}

async function tag_exists(tag: string) {
    let res = await wrap_db_get(querys.get_tag_id, [tag])
    if (res.err) {
        console.error(res.err.message)
        throw Error()
    }

    return res.row !== undefined
}

async function wrap_db_all(query: string, params: any): Promise<{ err: Error | null, rows: any[] }> {
    return new Promise(resolve => {
        db.all(query, params, (err, rows) => {
            resolve({ err, rows })
        })
    })
}

async function wrap_db_get(query: string, params: any): Promise<{ err: Error | null, row: any }> {
    return new Promise(resolve => {
        db.get(query, params, (err, row) => {
            resolve({ err, row })
        })
    })
}

async function wrap_db_run(query: string, params: any): Promise<Error | null> {
    return new Promise(resolve => {
        db.run(query, params, (err) => {
            resolve(err)
        })
    })
}

async function search_bookmarks(tags: string[]) {
    let query = querys.search_bookmark(tags.length)
    let res = await wrap_db_all(query, tags)
    if (res.err) {
        console.error(res.err.message)
        return []
    }
    return res.rows
}

async function handleAddBookmark(url: string, title: string, tags: string[], description: string): Promise<{ err: boolean, message: string }> {
    //
    // SQL文で実行すれば性能がよくなるかもしれないのにJSで実装している箇所
    //  繰り返し処理
    //  挿入したデータのIDを検索している
    //  
    // 理由
    //  SQLは苦手
    //  データの追加の処理だから性能は求めてない
    //

    //
    // バリデーションチェック
    //
    let errs = tags.map(t => value_check_tag(t)).filter(r => r.err === true)
    if (errs.length > 0) {
        return {
            err: true,
            message: errs.map(e => e.message).join("\n")
        }
    }


    //
    // テーブルにないタグを追加
    //
    let require_add_tags = []
    for (let i = 0; i < tags.length; i++) {
        const tag = tags[i];
        if (await tag_exists(tag) === false) {
            require_add_tags.push(tag)
        }
    }
    for (let i = 0; i < require_add_tags.length; i++) {
        const tag = require_add_tags[i];
        let res = await wrap_db_run(querys.add_tag, [tag, tag])
        if (res) { return { err: true, message: res.message } }
    }


    //
    // bookmarksに追加
    //
    let tag_count = tags.length
    let result_add_bkmk = await wrap_db_run(querys.add_bkmk, [title, url, description, tag_count])


    //
    // bookmarkとtagを結び付ける
    //
    let bkmk_id = await wrap_db_get(querys.get_bkmk_id, [title, url])
    let tag_ids = []
    for (let i = 0; i < tags.length; i++) {
        let res = await wrap_db_get(querys.get_tag_id, tags[i])
        if (res.err) { return { err: true, message: res.err.message } }
        tag_ids.push(res.row)
    }
    for (let i = 0; i < tags.length; i++) {
        let params = [bkmk_id.row.id, tag_ids[i].id]
        let res = await wrap_db_run(querys.add_tag_map, params)
        if (res) { return { err: true, message: res.message } }
    }


    return {
        err: false,
        message: ""
    }
}

async function fetch_hit_tags(tags: string[]): Promise<{
    err: Error | null,
    data: {
        name: string,
        count: number
    }[]
}> {

    let q = querys.fetch_hit_tags(tags)
    let result = await wrap_db_all(q.query, q.param)
    if (result.err !== null) {
        return {
            err: result.err,
            data: []
        }
    }

    return {
        err: null,
        data: result.rows
    }
}

async function handleFetchSuggestion(word: string) {
    let find_word = word + "%"
    let fuzzy = "%" + word + "%"
    let result = await wrap_db_all(querys.fetch_suggestion, [find_word, fuzzy, find_word])
    if (result.err) {
        return {
            err: true,
            message: result.err.message,
            data: null
        }
    }
    return {
        err: false,
        message: "",
        data: result.rows
    }
}

async function edit_tag(data: { name: string, oto: string, id: number }): Promise<{
    err: Error | null
}> {

    let q = querys.edit_tag(data.id, data.name, data.oto)
    let result = await wrap_db_run(q.query, q.param)

    if (result !== null) {
        return {
            err: result
        }
    }

    return {
        err: null
    }
}

async function fetch_tag_list() {
    let q1 = querys.fetch_tag_list()
    let tags = await wrap_db_all(q1.query, q1.param)
    if (tags.err !== null) {
        return {
            err: tags.err,
            data: []
        }
    }

    return {
        err: null,
        data: tags.rows
    }
}

function load_config_file(): any {

    if (!existsSync(CONFIG_DIR)) {
        mkdirSync(CONFIG_DIR, { recursive: true })
    } else if (lstatSync(CONFIG_DIR).isFile()) {
        throw Error()
    }

    if (!(existsSync(CONFIG_FILE_PATH))) {
        writeFileSync(CONFIG_FILE_PATH, "{}")
    }

    try {
        let text = readFileSync(CONFIG_FILE_PATH).toString()
        return JSON.parse(text)
    } catch {
        return {}
    }
}


function is_how_to_open_url_data(data: any): boolean {
    try {

        if (typeof data["cmd"] !== "string") {
            console.log("1--")
            return false
        }

        if (data["args"] instanceof Array === false) {
            console.log("2--")
            return false
        }

        if (data["args"].every((v: any) => typeof v === "string") === false) {
            console.log("3--")
            return false
        }


    } catch {
        return false
    }

    return true
}

function apply_config(config: any): Config {
    let ret_config: Config = {
        how_to_open_url: {}
    }

    Object.assign(ret_config.how_to_open_url, default_how_to_open_url)

    if (config["how_to_open_url"] !== undefined) {
        let alias = config["how_to_open_url"]

        for (let key in alias) {
            if (!is_how_to_open_url_data(alias[key])) {
                console.log(alias[key], "is false")
                continue
            }

            console.log(alias[key], "is ok")

            ret_config.how_to_open_url[key] = alias[key]
        }

    }

    return ret_config
}

//----------------------------------------------------------------------------------------------------//
//                                                                                                    //
//                                             SQL QUERY                                              //
//                                                                                                    //
//----------------------------------------------------------------------------------------------------//
const querys = {
    init: `
        create table if not exists bookmarks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title text,
            url text,
            description text,
            tag_count int not null,
            created_at datetime
        );

        create table if not exists tags (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name text unique,
            oto text
        );

        create table if not exists tag_map (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            bkmk_id int,
            tag_id int,
            FOREIGN KEY (bkmk_id) REFERENCES bookmarks (id),
            FOREIGN KEY (tag_id) REFERENCES tags (id)
        );
        `,

    search_bookmark: (length: number) => {
        let s = new Array(length).fill("?").join(",")
        return `
        SELECT b.*
        FROM bookmarks b
        JOIN tag_map tm ON b.id = tm.bkmk_id
        JOIN tags t ON tm.tag_id = t.id
        WHERE t.name IN (${s})
        GROUP BY b.id
        HAVING COUNT(DISTINCT t.name) = ${length}
        ORDER BY b.tag_count ASC
        ;
        `
    },

    fetch_hit_tags: (tags: string[]) => {
        let s = new Array(tags.length).fill("?").join(",")
        let query = `
        SELECT *
        FROM (
            SELECT name, COUNT(*) as count
            FROM tag_map
            JOIN tags t ON tag_map.tag_id = t.id
            WHERE bkmk_id IN (
                SELECT b.id
                FROM bookmarks b
                JOIN tag_map tm ON b.id = tm.bkmk_id
                JOIN tags t ON tm.tag_id = t.id
                WHERE t.name IN (${s})
                GROUP BY b.id
                HAVING COUNT(DISTINCT t.name) = ?
                ORDER BY b.tag_count DESC
            )
            GROUP BY tag_id
            ORDER BY COUNT(*) DESC
        )
        WHERE name NOT IN (${s})
        LIMIT 30
        `
        let param = [
            ...tags,
            tags.length,
            ...tags
        ]

        return { query, param }
    },

    get_tag_id: "select id from tags where name = ?",
    add_tag: "insert into tags values (null,?,?)",
    get_bkmk_id: "select id from bookmarks where title = ? and url = ?;",
    add_bkmk: "insert into bookmarks values (null,?,?,?,?,strftime('%Y-%m-%d', CURRENT_DATE));",
    add_tag_map: "insert into tag_map values (null,?,?)",
    get_bkmk_from_id: "select * from bookmarks where id = ?",

    fetch_suggestion: `
        select name,oto from tags where oto like ? 
        union all
        select name,oto from tags where oto like ? and oto not like ?;`,


    // TODO RENAME
    exists_tags: (len: number) => {
        let where = new Array(len).fill("where = ?")
        let stmt = "select id from tags " + where.join(" or ")
        return stmt
    },

    fetch_tag_list: () => {
        let query = "select * from tags;"
        let param = undefined
        return { query, param }
    },

    edit_tag: (id: number, new_name: string, new_oto: string) => {
        let query = "update tags set name = ?, oto = ? where id = ?"
        let param = [new_name, new_oto, id]
        return { query, param }
    }
}



//----------------------------------------------------------------------------------------------------//
//                                                                                                    //
//                                                MAIN                                                //
//                                                                                                    //
//----------------------------------------------------------------------------------------------------//

if (!existsSync(DATA_DIR)) {
    mkdirSync(DATA_DIR, { recursive: true })
} else if (lstatSync(DATA_DIR).isFile()) {
    throw Error()
}

const config = apply_config(load_config_file())

const db = new Database(DB_FILE_PATH, (err) => {
    if (err !== null) {
        console.error("connect", err)
        throw err
    }

    db.exec(querys.init, (err) => {
        if (err) {
            console.error("query_init", err)
            throw err
        }
    });
})

ipcMain.handle("fetch-hit-tags", async (_, tags) => await fetch_hit_tags(tags))
ipcMain.handle("add-bkmk", async (_, url, title, tags, description) => {
    let res = await handleAddBookmark(url, title, tags, description)
    return res
})


ipcMain.handle("fetch-tag-list", async () => await fetch_tag_list())
ipcMain.handle("fetch-suggestion", async (_, word) => {
    return await handleFetchSuggestion(word)
})

ipcMain.handle("fetch-pageinfo", async (_, url) => {
    let res

    try {
        res = await fetch(url)
    } catch {
        return null
    }

    if (res.status !== 200) {
        return null
    }

    let text = await res.text()

    let root = parse(text)
    let title_elm = root.querySelector("title")
    let title = title_elm === null ? null : title_elm.innerText

    let description_elm = root.querySelector('meta[name="description"]')
    let description = description_elm === null ? null : description_elm.attrs.content

    return {
        title,
        description
    }

})

ipcMain.handle("edit-tag", async (_, data) => await edit_tag(data))


ipcMain.handle("search-google", (_, tags) => {
    search_google(tags)
})

ipcMain.handle("tag-exists-db", async (_, tag_name) => {
    return await tag_exists(tag_name)
})


ipcMain.handle("search-bookmarks", async (_, tags: string[]) => {
    return await search_bookmarks(tags)
})

ipcMain.handle("open-bookmark", async (_, bookmark_id: number) => {
    return await open_bookmark(bookmark_id)
})

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

app.setName(APP_NAME)